---
title: "Exercise - Visualizations"
author: "Marc A.T. Teunis"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
# change these options to hide or show results, code and plots
knitr::opts_chunk$set(echo = FALSE,
                      fig.show = 'hide', 
                      results = 'hide', 
                      warning = FALSE, 
                      error = FALSE, 
                      message = FALSE)
```

```{r root_object, echo = TRUE}
## defines the root of the project for later use
require("rprojroot") || utils::install.packages("rprojroot")
library(rprojroot)
root <- find_root_file(criterion = is_rstudio_project)
```

## Packages
```{r, load_packages, echo=TRUE}
## the packages that you minimally need for this exercise
library(tidyverse)
library(cowplot)
library(readr)
library(readxl)
## add more if you need them
```

__Write an Rmd file, containing code chunks (if applicable) and answer all the questions below. Store the file in a folder called: "./answers_exercises" in your course project folder. Give this file the same name as the title of the current Rmd file__

## {ggplot2}
As shown in the lecture, the {ggplot2} package is a very strong tool to make plots. It is somewhat more difficult to master than other plotting systems in R, but it is much stronger and much, much more versatile.

In order to force you to study ggplot syntax, you will have to create plots in this exercise using {ggplot2} syntax only!!

## Introduction
In most cases, plotting is the main tool by which you get a ‘feel’ for the data. In many cases, the plots require some work on the data first, so we will have to process the data as well. A very important part of your preliminary analysis involves knowing the distribution of the data. That is, what are its typical values, and how do they relate to oneanother or to another data set. Probably the easiest plotting tool for this is the histogram. This is available as the `geom_histogram()` or `geom_freypoly()` in {ggplot2}.

## Exercise 1: Treatment Effect Relations
In this exercise we will use a build-in dataset from the {datasets} package. The data can be loaded by typing 
```
chicks <- datasets::ChickWeight
```
in your script. Try it now!

You will see a new object called chicks in you Global Environment.
```{r}
## load dataset ChickWeights
chicks <- datasets::ChickWeight 
```

1A) Inspect the data

 - Are there any missing values, if yes how many? (`sum(is.na()`)
 - What types of variables do we have? (use the `str()` command)
 - Convert to a tibble
 - Are all the variables of the right type?
 - Which variables are categorical?
 - Which are numeric?
 - Change grouping variables to facors if neccesary(`chicks$var <- as.factor(chicks$var)`)
 
```{r}
head(chicks)
sum(is.na(chicks)) # so no missing values
str(chicks) # you see that all variables have the right type
```

1B) Change all variable names to lower type case

Write a line of code that changes all `names()` of the variables to lower-case. 
```{r}
names(chicks) <- tolower(names(chicks))
names(chicks) <- c("weight", "time", "chick", "diet")  
head(chicks)
```

1C) Scatter plot of all the data

Create a plot in your Rmd script that shows all the data points. Plot the variable `time` on the x-axis and the variable `weight` on the y-axis.

**ANSWER**
```{r}
names(chicks)
plot_1c <-  ggplot(data = chicks, aes(x = time, y = weight)) +
  geom_point(aes(colour = diet), alpha = 0.4, position = "jitter") 

#  geom_jitter(aes(x = time, y = weight), position = "jitter") 
  
plot_1c
```

1D) Overplotting

You will see that the plot contains many points that are overlaid. How can you solve this "overplotting" problem?

**TIPs**

 - Look-up overplotting in the "R for Data Science" book
 - What does `alpha()` do?
 - Maybe use geom_jitter() as an extra layer in your graph
 (look at `?geom_jitter`)

**ANSWER**
```{r}
plot_1d_1 <-  ggplot(data = chicks, 
                   aes(x = time, y = weight)) +
  geom_point(alpha = 0.6) 
## setting alpha does not really solve the overplotting 
plot_1d_1

plot_1d_2 <-  ggplot(data = chicks, 
                   aes(x = time, y = weight)) +
  geom_point() + geom_jitter(position = "jitter") 
## setting "jitter" solves it
plot_1d_2

## antoher solution
plot_1d_3 <-  ggplot(data = chicks, 
                   aes(x = time, y = weight, color = diet)) +
  geom_point() + geom_jitter(position = "jitter") 
## setting "color = diet" provides even more insight
plot_1d_3

```

1E) Overplotting solved by colours

We could also solve the overplotting problem by using colour for each diet.
Add, `colour = diet` to the plot in such a way that you can see the diffences between the diets in one plot.

__Can you determine from this plot which diet has the strongest effect on the weight-gain per time on the chicks?__

**ANSWER**
```{r}
plot_1e <-  ggplot(data = chicks,
                   aes(x = time, y = weight, color = diet)) +
  geom_point()
plot_1e
```


1F) Combining "jitter" with group colours

Combining "jitter" with colours to reduce overplotting even more 

Combine adding "jitter" to the plot with asigning colours to diet.

**TIPs** 
 - Remember to `set.seed(1234)` to get a reproducible result.

**ANSWER**
```{r}
set.seed(1234)
plot_1f <-  ggplot(data = chicks,
                   aes(x = time, y = weight, color = diet)) +
  geom_point() +
  geom_jitter(position = "jitter")
plot_1f
```

1G) Solving overplotting by reducing data dimensionality: summarizing data

From the above plot it is still hard to see the trends in the data.

 - Summarize the data for each diet and make a plot on the summarized data. 
 - Again put `time` on the x-axis and the mean of the chick weight on the y-axis. 
 - Add appropriate labels to the plot, and a title.
 - Add regression curves (`geom_smooth(method = "lm"`) to the plot.

__Draw a conclusion: Which diet do you think shows the strongest effect on weight-gain over time in the investigated chicks?__

**TIPs**

 - For this you will need `dplyr::group_by()` and `dplyr::summarize`
 - call the new summarized dataframe: "chicks_summary"
 - Use `%>%` to create the "chicks_summary"
 - For this to work you will have to specify all the `aes()` arguments within the `ggplot()` call.
 
**ANSWER** 
```{r}
# summarize the chicks data with {dyplyr}
chicks_summary <- chicks %>%
  group_by(diet, time) %>%
  summarise(mean_weight = mean(weight)) 

# dot plot with a smoother, the method for smoothing is "linear model"
plot_1g <-  ggplot(data = chicks_summary, 
  aes(x = time, y = mean_weight, color = diet)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)

plot_1g


plot(chicks$time ~ chicks$chick) # base plotting R


```

## Statistics
Some thoughts on statitical analysis 
```{r}

aov2 <- aov(chicks$weight ~ chicks$diet)

summary(aov2)

tukey <- TukeyHSD(aov2)
tukey
```



## Exercise 2: Clinical dataset "Mondial"

A dataset from a clinical study of patients that underwent gastric surgery

Box plots can convey information on the variance in a dataset. It is useful for repeated measures data.

For this exercise we load the "Mondial" data. This dataset includes a number of clinical measurements from people who underwent gastric surgery.

## Load the "Mondial" data with the code below
```{r, echo=TRUE}
## tidyverse solution
# install.packages()
library(readr)
?read_rds
path_to_file <- file.path(root, "data", "mondial.Rda")
mondial <- read_rds(path = path_to_file)
```

## Cleaning up the data

 - Inspect the data
 - Change the variable names to all lowercase, no spaces, snake_case, no "()". 
 
Use the code below to perform these cleaning steps, discuss the steps in the code with you neighbour: Copy the code to you Rmd file for this exercise and add `##` comments to the code after the discussions.
```{r, echo=TRUE, results='markup'}
library(stringr)
head(mondial)
sum(is.na(mondial))
# all lower case
names(mondial) <- tolower(names(mondial))
# remove spaces
names(mondial) <- str_replace_all(names(mondial), 
            pattern = " ", replacement = "_")
# remove special characters (like "()")
names(mondial) <- str_replace_all(names(mondial), 
            pattern = "[[:punct:]]", replacement = "_")
# remove last trailing "_"
names(mondial) <- str_replace_all(names(mondial), 
            pattern = "_$", replacement = "")
# replace double "__" for single "_"
names(mondial) <- str_replace_all(names(mondial), 
            pattern = "__", replacement = "_")

names(mondial)
```

2A) Creating a box-plot to see variation in the data

Boxplots are great to get an idea on variance in the data and to identify varibles that contain outliers.

Generate a box plot for all `numeric` variables in the dataset.

The variables that you need to plot in this boxplot are:

```{r, echo=TRUE, results='markup'}
x <- names(mondial)[c(3, 14, 15, 16, 17, 18)]
x
```
Use the dataset `mondial_select` that is generated by the following code chunk for this plot

Put the variable `biomarker` on the x-axis and the variable `result` of `mondial_select` on the y-axis.

**TIPs**
 - use `dplyr::select()` to select the proper variables
 - use geom_boxplot to create a boxplot with {ggplot2}

2B)
__The code below generates a clean dataset with the proper variables selected to complete the exercise. Review the code and see if you can follow the step, discuss with you neighbour.__

```{r, echo=TRUE, results='markup'}
# selecting only numeric variables
names(mondial)

mondial_select <- mondial %>%
  select(study,
         t2d,
         age_at_surgery,
         length_cm,
         weight_kg,
         bmi,
         waist_circumference,
         fasting_glucose_mmol_l)

# In order to be able to create this graph we need to reshape the data to a "stacked" or so-called "long" format
names(mondial_select)
mondial_select <- mondial_select %>%
  gather(age_at_surgery:fasting_glucose_mmol_l, 
         key = biomarker, value = result)

head(mondial_select)
```

Create the box plot code in a code chunk below. Use the reshaped dataframe called "mondial_select" for this plot.

**ANSWER**
```{r}
# create boxplot
ggplot(data = mondial_select, 
       aes(x = biomarker, y = result)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

## Type-2 diabetes

In the `mondial` dataset we see the variable `t2d`. This variable is a logical indicating whether the patients in the dataset have Type-2 diabetes or not.

2C) Data inspection

 - Inspect the variable, what is the type of the variable?
 - There are supposed to be two levels in the variable. How many are there really. 
 - How could you correct the levels?
 
**TIPs**
 - We use `str_replace_all` the same way as above to correct the following entries
 
RUN the code chunk below that corrects the levels in the factor variable `t2d`

__Discuss the code below with your neighbour, can you follow all the steps?__
```{r, echo=TRUE, results='markup'}
class(mondial$t2d)
mondial$t2d <- as.factor(mondial$t2d)
levels(mondial$t2d)

(mondial <- as_tibble(mondial))
mondial$t2d <- tolower(mondial$t2d)
mondial$t2d <- str_replace_all(mondial$t2d,
                      pattern = "\\s",
                      replacement = "")
mondial$t2d <- str_replace_all(mondial$t2d,
                      pattern = "[[:punct:]]",
                      replacement = "")
mondial$t2d <- str_replace_all(mondial$t2d,
                      pattern = "glucoseintol",
                      replacement = "inconclusive")
mondial$t2d <- str_replace_all(mondial$t2d,
                      pattern = "gestoordnuchterglucose",
                      replacement = "inconclusive")
mondial$t2d <- str_replace_all(mondial$t2d,
                      pattern = "sindsmaagbandnietmeer",
                      replacement = "")
mondial$t2d <- str_replace_all(mondial$t2d,
                      pattern = "nee",
                      replacement = "no")
mondial$t2d <- as.factor(mondial$t2d)
levels(mondial$t2d)
```
 
2D) Facets for `t2d`
 
 Create a scatter plot using the `mondial` data (not `mondial_select`), put `fasting_glucose_mmol_l` on the x-axis and `weight` on the y-axis. create facets for the `t2d` variable. Create correct titel and axis-labels

**What can you conclude about the relation between fasting glucose, weight and type-2 diabetes?**
 
 **TIPs**
 
 - To facet a plot you can use either `facet_grid()` of `facet_wrap()` try them both, look up in the book "r4ds".
 - To generate a plot title, use `ggtitle()`
 - To label axis use `xlab` and `ylab` 
 
 **ANSWER**
```{r}
  names(mondial)

facets_t2d <- ggplot(data = mondial, 
                 aes(x = fasting_glucose_mmol_l,
                     y = weight_kg)) +
  geom_point() +
  facet_wrap( ~ t2d) +
  ggtitle("t2d vs fasting glucose levels in serum") +
  xlab("Serum glucose (mmol/L") +
  ylab("Body weight")
 
 facets_t2d
```

# **BONUS EXERCISE**

## Exercise 3; Relational Genomics Data
Exercise 3 is a bit more difficult and challenging exercise. It uses data in a form that is often used in the Lif Sciences: A Matrix with nummeric values. The file contains many variables, that are all deletions of certain genes. The rownames are the gene names for the gene in which the deletion was performed.

The datafile can be found in : "//root/data/exp_profiles_gstf.M.txt"

In two seperate files meta-data is stored that provides extra information:

 - information on the features (genes) can be found in "//root/data/SGD_features.txt"
 - information on the headers of the features file can be found in 
"//root/data/SGD_features.features" 

## Data load
The code below loads the data, copy it to your Rmd for this exercise.
Load the data from exp_profiles_gstf_cf.M.txt (This file contains the M values, or log2 fold-change gene expression changes caused by removing (deleting) a particular gene).
```{r, load_data, echo =  TRUE}
## defines the root of the project for later use
require("rprojroot") || utils::install.packages("rprojroot")
library(rprojroot)

## actual call for data load
root <- find_root_file(criterion = is_rstudio_project)
library(tidyverse)
file_path <- file.path(root, "data", "exp_profiles_gstf_cf.M.txt")

?read_table2
expression_gstf <- read.table(file = file_path)
```

## Histograms

3A) One histogram for one variable

Create a histogram for the variable `$msn2_del`. Play with the number of bins. Specify labels and provide a title.

**TIPs**

 - Remember to set the `mappings = (aes(msn2_del)` argument.
 - Play with the argument `bins = `
 - Use `ggtitle()`, `xlab()` and `ylab()` to create labels of the axes and the plot title
 
**ANSWER 3A**
```{r, histograms_3A}
ggplot(data = expression_gstf, mapping = aes(msn2_del)) +
  geom_histogram(bins = 100) + ylab("Count") +
  xlab("log2") + ggtitle("Histogram of msn2_del")
```

3B) Two distributions in one plot
Plot, in the same graph the distribution data for the phd1_del (use a different color. TIP: remember the difference between putting the mappings for aes in the ggplot() call and the geom_ call?).

Create two plots for 3B: one using `geom_histogram()` and one using `geom_freqpoly()`. Put the two plots in one panel. Plot a different color for each variable in your two plots.

Label the plot apropriately.

**TIPs**
 - To plot two geoms in one graph for two different variables, with two different colors: put the `aes()` call inside the call to the `geom_`, like below.

``` 
 plot <- `ggplot(data = ...) + 
 geom_histogram(aes(variable_1), bins = ..., color = "pick_a_color") +
  geom_histogram(aes(variable_2), bins = ..., color = "pick_another_color")
  
 - To plot multiple plots in a panel look at the package {cowplot}   
```

**ANSWER 3B**  
```{r}
## freqpoly
freqpoly <- ggplot(data = expression_gstf) +
  geom_freqpoly(aes(msn2_del), bins = 100, colour = "darkred") + 
  geom_freqpoly(aes(phd1_del), bins = 100, colour = "blue",
                alpha = 0.9) + 
  ylab("Count") +
  xlab("log2") + ggtitle("Freqpolys msn2_del & phd1_del")
freqpoly

## histograms
histograms <- ggplot(data = expression_gstf) +
  geom_histogram(aes(msn2_del), bins = 100, 
                 colour = "darkred") + 
  
  geom_histogram(aes(phd1_del), bins = 100, 
                 colour = "blue", alpha = 0.9) + 
  ylab("Count") +
  xlab("log2") + ggtitle("Histograms msn2_del phd1_del")

histograms
## to write the plot to a file
#?pdf
#pdf(file = paste0(root, "/images/exercise_histogram2_3.pdf"))
cowplot::plot_grid(freqpoly, histograms)
#dev.off()
```

## Transforming the data before plotting
If we want to plot multiple variables in one plot it is more convenient to change the dataset to a different format.

The code (we will learn how to do this later) for transforming the data to a stacked format is:
```{r, echo = TRUE, results='markup'}
# ?gather
# add extra column with gene names
expression_gstf$sgid <- rownames(expression_gstf)

expression_gstf_stacked <- expression_gstf %>%
  gather(swd1_del:btt1_del, key = deletions, value = log2)

head(expression_gstf_stacked)
```

The data is now in stacked format where we have counts for each variable in one colomn. The stacked format is more suitable to be able to plot groups of data.

## New histograms with the "stacked" dataset

3C) Create a set of frequency polynoms (`geom_freqpoly()`) that display the distibution of three deletions in the data: "ms2_del", "nhp6b_del" and "fkh1_del"
Use the new dataset "expression_gstf_selected" created by the code below to create the plot
```{r, echo=TRUE, results='markup'}
str(expression_gstf_stacked)
## convert grouping variables to factors
expression_gstf_stacked$sgid <- as.factor(expression_gstf_stacked$sgid)
expression_gstf_stacked$deletions <- as.factor(expression_gstf_stacked$deletions)

## selecting data from "nhp6a_del","nhp6b_del" and "fkh1_del" only
expression_gstf_selected <- expression_gstf_stacked %>% 
  filter(deletions == "msn2_del" | 
         deletions == "nhp6b_del" |                                             
          deletions == "fkh1_del")
head(expression_gstf_selected)
```

**ANSWER 3C**
```{r}
freqpoly_new <- ggplot(data = expression_gstf_selected) +
  geom_freqpoly(aes(x = log2, color = deletions), 
                stat = "density")
freqpoly_new
```

3D) Scatter plot

Scatter plots are used to show relations between two numerical variables. Transcription factors 
`rtg1` and `rtg3` function together as a dimer, so you would expect the transcriptional response to be similar for these deletions.  Plot them against each other to see if this holds.

Use the dataset `expression_gstf` to answer 3D

**TIPs**

 - Try to solve overplotting issues with settign alpha for transparency of the points 

```{r}

ggplot(data = expression_gstf, aes(x = rtg1_del, y = rtg3_del)) +
  geom_point(alpha = 0.5) +
  ggtitle("RTG1 vs RTG3") +
  xlab("RTG1 (log2M)") +
  ylab("RTG3 (log2M)")

```


Let’s add to this plot a text showing the linear correlation between the two. It is calculated using the `annotate()` function. To position the annotation you can specify coordinates that correspond to the x- and y-axis values. For example, see what happens to the annotation when you specify `x = -2, y = 5`. Try different values until you are satisfied. `annnotate()` also takes extra argument that specify the type of the label. Choose "text" here.  

First calculate the correlation between rtg1 and rtg2 using the `cor()` function.

```{r, echo=TRUE}
cor <- cor(expression_gstf$rtg1_del, expression_gstf$rtg3_del)
cor <- round(cor, 4)
```

Use the cor label to annotate the plot from 3D.

```{r}
cor <- cor(expression_gstf$rtg1_del, expression_gstf$rtg3_del)
cor <- round(cor, 4)

ggplot(data = expression_gstf, aes(x = rtg1_del, y = rtg3_del)) +
  geom_point(alpha = 0.5) +
  ggtitle("RTG1 vs RTG3") +
  xlab("RTG1 (log2M)") +
  ylab("RTG3 (log2M)") +
  annotate("text", x = -2, y = 5, 
           label = paste("corr. coeffiecient", cor, sep = " "))
```

Let’s highlight the genes that are significantly changed. For this we need the p-values. You can find them in exp_profiles_gstf_cf.p_value.txt. Read this into your session. Do the files have the same row and column names? 

How would you check this using the functions all(), rownames() and colnames()  and the `==` operator? Use `names()` to get the variable names.

**TIPs**

 - Get the genes for which the p-value is < 0.05
 - Select these genes from the `expression_stacked` dataset by using indexing, create a new dataset from this filtered data, call this `significant_gstf`
 - Create a scatter plot where you plot `deletions` vs `log2`
 - Highlight in this plot the non-significant genes. Set the aes for the second layer to `data = non_significant_deletions`
 
```{r}
path_to_pvalues <- file.path(root, "data", "exp_profiles_gstf_cf.p_value.txt")
p_values <- read_tsv(path_to_pvalues)

names(p_values)
significant_gstf <- p_values %>% gather(swd1_del:btt1_del, key = deletions, value = p_value) 

significant_gstf <- significant_gstf %>% filter(p_value < 0.05)

index <- unique(significant_gstf$X1)
non_significant_deletions <- expression_gstf_stacked %>%
  filter(!sgid %in% index)
```

```{r, eval=FALSE}
# plot attempt

sample <- sample_frac(expression_gstf_stacked, 0.3)


final_plot <- ggplot(data = sample, aes(x = deletions, y = log2)) +
  geom_point(alpha = 0.9) +
  ggtitle("All deletions - Not-significant") +
  xlab("Deletions") +
  ylab("Log2(M)") +
  geom_point(data = non_significant_deletions, 
             aes(x = deletions, y = log2), color = "darkred", alpha = 0.9)

path_to_file <- file.path(root, "images", "non_significant_expression_gstf.png")
png(file = path_to_file, res = 100)
final_plot
dev.off()
final_plot
```

---
title: "Writing functions - Exercise"
author: "Marc A.T. Teunis"
date: '`r Sys.Date()`'
output:
  html_document:
    css: ~/hp_r_course/exercises/exercises_style.css
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE, 
                      error = FALSE,
                      results = 'hide',
                      fig.show = 'hide')
```

```{r, root_1, include=FALSE}
## defines the root of the project for later use
require("rprojroot") || utils::install.packages("rprojroot")
library(rprojroot)
root <- find_root_file(criterion = is_rstudio_project)
```

__Write an Rmd file, containing code chunks (if applicable) and answer all the questions below. Store the file in a folder called: "./answers_exercises" in your course project folder. Give this file the same name as the title of the current Rmd file__

## General function model

In the lecture you saw that the general form a function in R takes is:

```
some_descriptive_function_name <- function(function_arguments, ...){

 if(some_condition_on_the_argument(s)){ 
   message("some message telling that some condition does 
   meet, concerning the argument")
 } else {
   warning/stop("condition does not meet criteria for agument")
 }
 
  * some operations on the function arguments
  * some more calculations, 
  * maybe reshaping the object or looping or transforming

  return(whatever_the_function_returns)

}
```

## Writing functions is difficult
Note that writing functions is difficult. It has a steep learning curve an d it is an essential part of working with R. Spend time on this and you wille reward yourself for it in the future if you want to work with programming languages.

## Do not repeat youself.
Rember! If you find youself typing the same thing more than two times in R: write a function

## Write a function that can calculate the "mean()" of a numeric (vector).
 
 - You are not allowed to use the build-in function `mean()`
 - You may use the preexisting function `sum()` 
 - The function has to provide a `stop()` if the argument is non-numeric and a message if the argument is numeric.
 - Test the function with the two vectors below
 - Name your function: "`calculate_mean()`"

```{r}
set.seed(1234)
test_numeric <- rnorm(100)
test_non_numeric <- c("Wolf", "Deer", "Cayote", "Tiger")
```

**MODEL**
```{r, eval=FALSE, echo=TRUE}

calculate_mean <- function(numeric_vector){
  
  # step 1: test if argument is numeric, `stop()` if not

    # model for step 1
  if(is.numeric(numeric_vector)){
    message("write a clear message what the function is doing with the input here")
  } else {
    stop("write the error stop message here")
  }

  # step 2: calculate the sum of 'numeric_vector'
  # step 3: determine the length of 'numeric_vector'
  # step 4: divide sum by length 
  # step 5: return result of the function with `return(result)`

}
``` 

**ANSWER**
```{r, eval=FALSE}  

calculate_mean <- function(numeric_vector){
 
# step 1: 
  if(is.numeric(numeric_vector)){
 
     message("input vector is numeric. Calculating mean over argument")
  
   } else {
    stop("input vector is not numeric, cannot determine mean over non-numeric arguments, quitting.")
  
    }
  
# step 2:
  sum <- sum(numeric_vector)
  
# step 3:
  length <- length(numeric_vector)
  
# step 4: 
  mean <- sum/length
  
  return(mean)  

}
 set.seed(1234)
test_numeric <- rnorm(100)
test_non_numeric <- c("Wolf", "Deer", "Cayote", "Tiger") 
calculate_mean(test_numeric)  
calculate_mean(test_non_numeric)
```

## Extending a function with additional options
1B) Build onto the function created at 1A: The function has to return the mean and has to state whether the input is an integer, a numeric  or a logical vector. 

And if the input is character, it has to stop and display an error message

 - Tip, use multiple `if()` statements and an `else()` to accomplish this
 - Maybe use `if()` and `else if()`?
 - Use the following format
 - Note: you can calculate the mean of a logical vector: Each TRUE in the vector will be automatically converted to a 1, each FALSE will be converted to a 0.
 - Use the following vectors to test your extended function
 - Call your function `calculate_mean_extended()`

```
vector_1 <- c(1:4)
vector_2 <- c("Tiger", "Wolf", "Zebra")
vector_3 <- c(1.3, 1.6, 4.6, 7.8)
vector_4 <- as.logical(c(0,1,1,1,1,1,0,0,0,0,0,1,0))
vector_5 <- c(TRUE, FALSE, FALSE, TRUE, TRUE)
``` 

**if() MODEL**
```
if(is.numeric(vector)){ 
message("argument is numeric, calculating mean")
}

The if statment will be evaluated, if the statement is TRUE, the message will be displayed  
```

**ANSWER**
```{r, eval=FALSE}  
calculate_mean_extended <- function(vector) {
 
# step 1: 
  
  if(is.numeric(vector)){ 
     message("Argument is numeric, calculating mean")
  }
  
  if(is.integer(vector)){
     message("Argument is an integer, calculating mean")
  }
  
  if(is.logical(vector)){
     message("Argument is a logical. Converting 'FALSE' to 0 and 'TRUE' to 1, calculating average of zeros and ones. A value of >0.5 will mean that there are more TRUEs than FALSEs in the vector. A value of <0.5 will mean that there are more FALSEs than TRUEs")
  }
  
  if(is.character(vector)){ 
    stop("argument is a character (vector). Cannot calculate mean over a vector of elements of type 'character'", call. = FALSE)
  }
  
# step 2:
  sum <- sum(vector)
  
# step 3:
  length <- length(vector)
  
# step 4: 
  mean <- sum/length
  
  return(mean)  
}
  

vector_1 <- c(1:4)
vector_2 <- c("Tiger", "Wolf", "Zebra")
vector_3 <- c(1.3, 1.6, 4.6, 7.8)
vector_4 <- as.logical(c(0,1,1,1,1,1,0,0,0,0,0,1,0))
vector_5 <- c(TRUE, FALSE, FALSE, TRUE, TRUE)
  
is.numeric(vector_1)
is.integer(vector_1)  
is.character(vector_3)

calculate_mean_extended(vector_1)
calculate_mean_extended(vector_2)
calculate_mean_extended(vector_3)
calculate_mean_extended(vector_4)
calculate_mean_extended(vector_5)
  
```

## Functions with multiple vector arguments

2A) Create a function that will return the (vectorized) sum of 2 integers.

 * Add a warning for integers that do not have the same lenght, the function does not need to stop at this.

**ANSWER**
```{r, eval=FALSE}
sum_integers <- function(integer_1, integer_2){

  if(length(integer_1) == length(integer_2)){
  } else {
  message("integer arguments are not of the same length, recycling the shortest integer to calculate sum")   
  }
  
  sum_integers <- integer_1 + integer_2
  return(sum_integers) 

}  

# equal length
sum_integers(integer_1 = c(1L:5L), integer_2 = c(11L:15L))
# onequal lenght
sum_integers(integer_1 = c(1L:5L), integer_2 = c(10L:35L))
# check function with existing function `sum()`
sum(integer_1 = c(1L:5L), integer_2 = c(10L:35L))
```

2B) Create a function that will return TRUE if a given integer is inside a vector.

 * Use is `integer()`
 * Use `lapply()` look up the help on this function with `?lapply`
 * Write a `stopifnot()` if the argument is a character vector  
 
```{r}

is_integer_present <- function(vector, integer){

  stopifnot(!is.character(vector))
  
  integer_present <- vector == integer
  true_false <- any(integer_present)

  return(true_false)
  }

is_integer_present(vector = c(1:40), integer = 39)
```

## Function with data.frame input
3) Create a function that given a data frame will print to screen the name of the column and the class of data it contains (e.g. Variable1 is Numeric).

 - Remember `typof()`, it can be used to get the type/class of a vector
 - The function `names()` returns the names of a vector, list or dataframe
 - Use `lapply()` and `typeof()` to tackle multiple columns 
 - You can use `unlist()` to unlist the result of `lapply()`
 - Use `tibble()` to generate the final result
 - Do you need a warning or an error message to check the class of the input?
 
**ANSWER**
```{r, eval=FALSE}
library(tidyverse)

print_colnames_and_types <- function(df){
  
  if(!is.data.frame(df)){
    stop("input must be of class 'data.frame'")
  } else {
  
  names_vars <- names(df)
  types_vars <- unlist(lapply(df, typeof))
  }
  
  result <- tibble(names_vars, types_vars)
  return(result)
}

# create tibble to check function
first_var = as.numeric(1:10) 
second_var = letters[1:10]
third_var = as.logical(1:10)
test_df <- tibble(first_var, second_var, third_var)

is.list(test_df)
is.data.frame(test_df)
print_colnames_and_types(test_df)

# create list to check function error message
a = as.numeric(1:10)
b = as.numeric(11:20)
d = as.numeric(21:30)
list <- list(a, b, d)
typeof(list)
print_colnames_and_types(list)

# create matrix to check function error message
matrix <- as.matrix(cbind(a, b, d))
print_colnames_and_types(matrix)
names(matrix)
is.matrix(matrix)
```

## Understanding what functions do
4) Read the source code for each of the following three functions, puzzle out what they do, discuss with your neighbour and then brainstorm better names.
    
```{r}
f1 <- function(string, prefix) {
  substr(string, 1, nchar(prefix)) == prefix
}

f2 <- function(x) {
  if (length(x) <= 1) return(NULL)
  x[-length(x)]
}

f3 <- function(x, y) {
  rep(y, length.out = length(x))
}
```

## Conditonal functions
5) Write a greeting function that says "good morning", "good afternoon",
or "good evening", depending on the time of day. (Hint: use a time
argument that defaults to `lubridate::now()`. That will make it 
easier to test your function.)

 - Look at `?lubridate::now()` 
 - Use `lubridate::now(tzone = "UTC-2:00")` to get the current local time
 - Use `if()` and `else()`
 - First write working code and than put the code in a function
 - Call your function `greetings()`
 - If you use `libridate::now()` you will get the date and the time of day. How could you split the vector in two? Maybe use `stringr::str_split`? Look at the help for `str_split()`.

```{r, eval=FALSE}
greetings <- function(){

now <- lubridate::now("UTC-2:00")
now <- unlist(stringr::str_split(now, pattern = " "))
now <- now[2]

if(now <= "12:00:00" & now >= "05:00:00"){cat("Good Morning!")}
if(now > "12:00:00" & now <= "18:00:00"){cat("Good Afternoon!")}
if(now > "18:00:00" & now <= "23:00:00"){cat("Good Evening!")}
if(now > "23:00:00" & now < "05:00:00"){cat("Good Night!")}
}

greetings()
```

# BONUS QUESTIONS
6) More conditional calculations

Implement a `fizzbuzz` function. It takes a single number as input. If the number is divisible by three, it returns "fizz". If it's divisible by five it returns "buzz". If it's divisible by three and five, it returns "fizzbuzz". Otherwise, it returns the number. Make sure you first write working code before you create the function.

    
7) Finding motifs in DNA strings
Finding motifs of usually shorter DNA strings in longer so-called 'subject' DNA sequences 


With the provided code below, build a function that takes two aguments: a path to a fasta file containing DNA subject strings, and a path to a fasta file that contains patterns to match to the subject strings.

Write a function that returns the positions of all the matches of the patterns in all the subjects.

The function Biostrings::DNAString turns a character string into a DNA string. The string can only contain letters of the DNA alfabet.
The function Biostrings::DNAStringSet and DNAStringSetList do the same, but for a set or a list of sequences, respectively

To see the letters of the DNA alfabet:
```{r, echo=TRUE}
library(Biostrings)
DNA_ALPHABET
```

The code below loads two files with lists of longer "subject" DNA-sequences and a list of shorter "pattern" sequences.

Write a function that matches all the shorter sequences to all longer sequences.
The output of the function has to be listt of so-called matches.

 - use the function `Biostrings::vmatchPattern`
 

The following code reads 1000 random sequences from a fasta data file
```{r, echo = TRUE}
library(pacman)
p_load(seqinr)

path_to_fasta_file <- file.path(root, "data", "random_1000_dna.fasta")
random_sequences <- seqinr::read.fasta(path_to_fasta_file, 
                                          as.string = TRUE,
                                          seqtype = "DNA",
                                          seqonly = FALSE)


```
 
The following code reads 10 randomly generated shorter (8 bases) DNA strings
```{r, echo=TRUE}
path_to_patterns_file <- file.path(root, "data", "patterns_10_dna.fasta")
pattern_sequences <- seqinr::read.fasta(path_to_patterns_file, 
                                          as.string = TRUE,
                                          seqtype = "DNA",
                                          seqonly = FALSE)

``` 

### Convert to DNAStringSetList
```{r, echo=TRUE}
subjects <- unlist(DNAStringSetList(random_sequences))
patterns <- unlist(DNAStringSetList(pattern_sequences))
names(patterns) <- c(1:length(patterns))
names(subjects) <- c(1:length(subjects))
pdict <- PDict(patterns)
head(subjects)
head(patterns)
```

To find a match of a pattern in a DNA string we can use `Biostrings::matchPdict`. Look at the help function.

The code below is the essential part of the function to be written. You see the replication that is going on! Rewrite this to a function, 

 - TIP: use sapply to get the matches of all the subjects
 - You have to write a function in a function to achieve your goal
 - Call you function `find_motifs()`
 
```{r, echo=TRUE}

?matchPattern
match <- matchPDict(pdict = pdict, subject = subjects[[1]])
matching_sequence <- Biostrings::extractAllMatches(subject = subjects[[1]], match)
matching_sequence

match <- matchPDict(pdict = pdict, subject = subjects[[2]])
matching_sequence <- Biostrings::extractAllMatches(subject = subjects[[2]], match)
matching_sequence

match <- matchPDict(pdict = pdict, subject = subjects[[3]])
matching_sequence <- Biostrings::extractAllMatches(subject = subjects[[3]], match)
matching_sequence

```
    
**CONCEPT ANSWER**    
```{r, eval=FALSE}
path_to_fasta_file_patterns <- file.path(root, "data", "patterns_10_dna.fasta")
path_to_fasta_file_subjects <- file.path(root, "data", "random_1000_dna.fasta")

find_motifs <- function(path_to_fasta_file_patterns, 
                        path_to_fasta_file_subjects){
  
  
  # load patterns fasta file
  sequences_patterns <- seqinr::read.fasta(path_to_fasta_file_patterns, 
                                          as.string = TRUE,
                                          seqtype = "DNA",
                                          seqonly = FALSE)

  # load subjects fasta file
  sequences_subjects <- seqinr::read.fasta(path_to_fasta_file_subjects, 
                                          as.string = TRUE,
                                          seqtype = "DNA",
                                          seqonly = FALSE)
  # convert to DNAStrings
  patterns <- unlist(Biostrings::DNAStringSetList(sequences_patterns))
  subjects <- unlist(Biostrings::DNAStringSetList(sequences_subjects))
  
  # optional, conditonal check for unique names of patterns and subjects 
  
  length_names_patterns <- length(unique(names(patterns))) 
  length_patterns <- length(patterns) 
  
  # conditional check for unique names of patterns
  if((length_names_patterns == length_patterns) == FALSE){
  message("Names of patterns are not unique, changing names to \n 
          incremental numbers '1:length of patterns'")
     
     # change names of patterns 
     names(patterns) <- c(1:length(patterns))  
  } 
  
  length_names_subjects <- length(unique(names(subjects))) 
  length_subjects <- length(subjects) 
  
  # conditional check for unique names of subjects
  if((length_names_subjects == length_subjects) == FALSE){
  message("Names of subjects are not unique, changing names to \n
          incremental numbers '1:length of subjects'")
      
      # change names of subjects  
      names(subjects) <- c(1:length(subjects))  
  } 
  
  # PDict: "Dictionary to store patterns, create a look-up table" 
  pdict <- Biostrings::PDict(patterns)

  subjects_set <- Biostrings::DNAStringSet(subjects)
  
  match_patterns <- function(subj){
    
    match_object <- Biostrings::matchPDict(pdict = pdict, subj)
    
    matching_sequence <- Biostrings::extractAllMatches(subj, match_object)

      }
    
  result <- sapply(subjects_list, match_patterns)
  
  return(result)
  
  
}

result_test_motifs <- find_motifs(path_to_fasta_file_patterns =                                                             path_to_fasta_file_patterns,
   
                                     path_to_fasta_file_subjects =                                                             path_to_fasta_file_subjects)
Biostrings::Views(result_test_motifs)
```
    
    